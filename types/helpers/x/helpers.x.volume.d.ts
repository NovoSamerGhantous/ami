export default class _default extends Object3D<import("three").Event> {
    constructor();
    _file: any;
    _progressbarContainer: any;
    _stack: any;
    _centerLPS: any;
    _xSlice: {
        _stack: any;
        _bBox: {
            _stack: any;
            _visible: boolean;
            _color: number;
            _material: import("three").Material | import("three").Material[] | import("three").MeshBasicMaterial;
            _geometry: import("three").BoxGeometry;
            _mesh: import("three").BoxHelper;
            _meshStack: import("three").Mesh<import("three").BoxGeometry, any>;
            visible: boolean;
            color: number;
            _create(): void;
            _update(): void;
            dispose(): void;
            id: number;
            uuid: string;
            name: string;
            type: string;
            parent: Object3D<import("three").Event>;
            children: Object3D<import("three").Event>[];
            up: import("three").Vector3;
            readonly position: import("three").Vector3;
            readonly rotation: import("three").Euler;
            readonly quaternion: import("three").Quaternion;
            readonly scale: import("three").Vector3;
            readonly modelViewMatrix: import("three").Matrix4;
            readonly normalMatrix: import("three").Matrix3;
            matrix: import("three").Matrix4;
            matrixWorld: import("three").Matrix4;
            matrixAutoUpdate: boolean;
            matrixWorldNeedsUpdate: boolean;
            layers: import("three").Layers;
            castShadow: boolean;
            receiveShadow: boolean;
            frustumCulled: boolean;
            renderOrder: number;
            animations: import("three").AnimationClip[];
            userData: {
                [key: string]: any;
            };
            customDepthMaterial: import("three").Material;
            customDistanceMaterial: import("three").Material;
            readonly isObject3D: true;
            onBeforeRender: (renderer: import("three").WebGLRenderer, scene: import("three").Scene, camera: import("three").Camera, geometry: import("three").BufferGeometry, material: import("three").Material, group: import("three").Group) => void;
            onAfterRender: (renderer: import("three").WebGLRenderer, scene: import("three").Scene, camera: import("three").Camera, geometry: import("three").BufferGeometry, material: import("three").Material, group: import("three").Group) => void;
            applyMatrix4(matrix: import("three").Matrix4): void;
            applyQuaternion(quaternion: import("three").Quaternion): any;
            setRotationFromAxisAngle(axis: import("three").Vector3, angle: number): void;
            setRotationFromEuler(euler: import("three").Euler): void;
            setRotationFromMatrix(m: import("three").Matrix4): void;
            setRotationFromQuaternion(q: import("three").Quaternion): void;
            rotateOnAxis(axis: import("three").Vector3, angle: number): any;
            rotateOnWorldAxis(axis: import("three").Vector3, angle: number): any;
            rotateX(angle: number): any;
            rotateY(angle: number): any;
            rotateZ(angle: number): any;
            translateOnAxis(axis: import("three").Vector3, distance: number): any;
            translateX(distance: number): any;
            translateY(distance: number): any;
            translateZ(distance: number): any;
            localToWorld(vector: import("three").Vector3): import("three").Vector3;
            worldToLocal(vector: import("three").Vector3): import("three").Vector3;
            lookAt(vector: number | import("three").Vector3, y?: number, z?: number): void;
            add(...object: Object3D<import("three").Event>[]): any;
            remove(...object: Object3D<import("three").Event>[]): any;
            removeFromParent(): any;
            clear(): any;
            attach(object: Object3D<import("three").Event>): any;
            getObjectById(id: number): Object3D<import("three").Event>;
            getObjectByName(name: string): Object3D<import("three").Event>;
            getObjectByProperty(name: string, value: string): Object3D<import("three").Event>;
            getWorldPosition(target: import("three").Vector3): import("three").Vector3;
            getWorldQuaternion(target: import("three").Quaternion): import("three").Quaternion;
            getWorldScale(target: import("three").Vector3): import("three").Vector3;
            getWorldDirection(target: import("three").Vector3): import("three").Vector3;
            raycast(raycaster: import("three").Raycaster, intersects: import("three").Intersection<Object3D<import("three").Event>>[]): void;
            traverse(callback: (object: Object3D<import("three").Event>) => any): void;
            traverseVisible(callback: (object: Object3D<import("three").Event>) => any): void;
            traverseAncestors(callback: (object: Object3D<import("three").Event>) => any): void;
            updateMatrix(): void;
            updateMatrixWorld(force?: boolean): void;
            updateWorldMatrix(updateParents: boolean, updateChildren: boolean): void;
            toJSON(meta?: {
                geometries: any;
                materials: any;
                textures: any;
                images: any;
            }): any;
            clone(recursive?: boolean): any;
            copy(source: any, recursive?: boolean): any;
            addEventListener<T extends string>(type: T, listener: import("three").EventListener<import("three").Event, T, any>): void;
            hasEventListener<T_1 extends string>(type: T_1, listener: import("three").EventListener<import("three").Event, T_1, any>): boolean;
            removeEventListener<T_2 extends string>(type: T_2, listener: import("three").EventListener<import("three").Event, T_2, any>): void;
            dispatchEvent(event: import("three").Event): void;
        };
        _slice: {
            _stack: any;
            _invert: any;
            _lut: string;
            _lutTexture: any;
            _intensityAuto: boolean;
            _interpolation: number;
            _index: number;
            _windowWidth: any;
            _windowCenter: any;
            _opacity: number;
            _rescaleSlope: any;
            _rescaleIntercept: any;
            _spacing: number;
            _thickness: number;
            _thicknessMethod: number;
            _lowerThreshold: any;
            _upperThreshold: any;
            _canvasWidth: number;
            _canvasHeight: number;
            _borderColor: any;
            _planePosition: import("three").Vector3;
            _planeDirection: import("three").Vector3;
            _aaBBspace: string;
            _material: import("three").ShaderMaterial;
            _textures: any[];
            _shadersFragment: typeof import("../../ami").DataFragmentShader;
            _shadersVertex: typeof import("../../ami").DataVertexShader;
            _uniforms: {
                uTextureSize: {
                    type: string;
                    value: number;
                    typeGLSL: string;
                };
                uTextureContainer: {
                    type: string;
                    value: any[];
                    typeGLSL: string;
                    length: number;
                };
                uDataDimensions: {
                    type: string;
                    value: number[];
                    typeGLSL: string;
                };
                uWorldToData: {
                    type: string;
                    value: import("three").Matrix4;
                    typeGLSL: string;
                };
                uWindowCenterWidth: {
                    type: string;
                    value: number[];
                    typeGLSL: string;
                    length: number;
                };
                uLowerUpperThreshold: {
                    type: string;
                    value: number[];
                    typeGLSL: string;
                    length: number;
                };
                uRescaleSlopeIntercept: {
                    type: string;
                    value: number[];
                    typeGLSL: string;
                    length: number;
                };
                uNumberOfChannels: {
                    type: string;
                    value: number;
                    typeGLSL: string;
                };
                uBitsAllocated: {
                    type: string;
                    value: number;
                    typeGLSL: string;
                };
                uInvert: {
                    type: string;
                    value: number;
                    typeGLSL: string;
                };
                uLut: {
                    type: string;
                    value: number;
                    typeGLSL: string;
                };
                uTextureLUT: {
                    type: string;
                    value: any[];
                    typeGLSL: string;
                };
                uLutSegmentation: {
                    type: string;
                    value: number;
                    typeGLSL: string;
                };
                uTextureLUTSegmentation: {
                    type: string;
                    value: any[];
                    typeGLSL: string;
                };
                uPixelType: {
                    type: string;
                    value: number;
                    typeGLSL: string;
                };
                uPackedPerPixel: {
                    type: string;
                    value: number;
                    typeGLSL: string;
                };
                uInterpolation: {
                    type: string;
                    value: number;
                    typeGLSL: string;
                };
                uCanvasWidth: {
                    type: string;
                    value: number;
                    typeGLSL: string;
                };
                uCanvasHeight: {
                    type: string;
                    value: number;
                    typeGLSL: string;
                };
                uBorderColor: {
                    type: string;
                    value: number[];
                    typeGLSL: string;
                };
                uBorderWidth: {
                    type: string;
                    value: number;
                    typeGLSL: string;
                };
                uBorderMargin: {
                    type: string;
                    value: number;
                    typeGLSL: string;
                };
                uBorderDashLength: {
                    type: string;
                    value: number;
                    typeGLSL: string;
                };
                uOpacity: {
                    type: string;
                    value: number;
                    typeGLSL: string;
                };
                uSpacing: {
                    type: string;
                    value: number;
                    typeGLSL: string;
                };
                uThickness: {
                    type: string;
                    value: number;
                    typeGLSL: string;
                };
                uThicknessMethod: {
                    type: string;
                    value: number;
                    typeGLSL: string;
                };
            };
            _geometry: any;
            _mesh: any;
            _visible: boolean;
            stack: any;
            spacing: number;
            thickness: number;
            thicknessMethod: number;
            windowWidth: any;
            windowCenter: any;
            opacity: number;
            upperThreshold: any;
            lowerThreshold: any;
            rescaleSlope: any;
            rescaleIntercept: any;
            invert: any;
            lut: string;
            lutTexture: any;
            intensityAuto: boolean;
            interpolation: number;
            index: number;
            planePosition: import("three").Vector3;
            planeDirection: import("three").Vector3;
            halfDimensions: any;
            _halfDimensions: any;
            center: any;
            _center: any;
            aabbSpace: string;
            mesh: any;
            geometry: any;
            canvasWidth: number;
            canvasHeight: number;
            borderColor: any;
            _init(): void;
            _toAABB: any;
            _create(): void;
            updateIntensitySettings(): void;
            updateIntensitySettingsUniforms(): void;
            updateIntensitySetting(setting: any): void;
            _update(): void;
            dispose(): void;
            cartesianEquation(): import("three").Vector4;
            _createMaterial(extraOptions: any): void;
            _updateMaterial(): void;
            _prepareTexture(): void;
            id: number;
            uuid: string;
            name: string;
            type: string;
            parent: Object3D<import("three").Event>;
            children: Object3D<import("three").Event>[];
            up: import("three").Vector3;
            readonly position: import("three").Vector3;
            readonly rotation: import("three").Euler;
            readonly quaternion: import("three").Quaternion;
            readonly scale: import("three").Vector3;
            readonly modelViewMatrix: import("three").Matrix4;
            readonly normalMatrix: import("three").Matrix3;
            matrix: import("three").Matrix4;
            matrixWorld: import("three").Matrix4;
            matrixAutoUpdate: boolean;
            matrixWorldNeedsUpdate: boolean;
            layers: import("three").Layers;
            visible: boolean;
            castShadow: boolean;
            receiveShadow: boolean;
            frustumCulled: boolean;
            renderOrder: number;
            animations: import("three").AnimationClip[];
            userData: {
                [key: string]: any;
            };
            customDepthMaterial: import("three").Material;
            customDistanceMaterial: import("three").Material;
            readonly isObject3D: true;
            onBeforeRender: (renderer: import("three").WebGLRenderer, scene: import("three").Scene, camera: import("three").Camera, geometry: import("three").BufferGeometry, material: import("three").Material, group: import("three").Group) => void;
            onAfterRender: (renderer: import("three").WebGLRenderer, scene: import("three").Scene, camera: import("three").Camera, geometry: import("three").BufferGeometry, material: import("three").Material, group: import("three").Group) => void;
            applyMatrix4(matrix: import("three").Matrix4): void;
            applyQuaternion(quaternion: import("three").Quaternion): any;
            setRotationFromAxisAngle(axis: import("three").Vector3, angle: number): void;
            setRotationFromEuler(euler: import("three").Euler): void;
            setRotationFromMatrix(m: import("three").Matrix4): void;
            setRotationFromQuaternion(q: import("three").Quaternion): void;
            rotateOnAxis(axis: import("three").Vector3, angle: number): any;
            rotateOnWorldAxis(axis: import("three").Vector3, angle: number): any;
            rotateX(angle: number): any;
            rotateY(angle: number): any;
            rotateZ(angle: number): any;
            translateOnAxis(axis: import("three").Vector3, distance: number): any;
            translateX(distance: number): any;
            translateY(distance: number): any;
            translateZ(distance: number): any;
            localToWorld(vector: import("three").Vector3): import("three").Vector3;
            worldToLocal(vector: import("three").Vector3): import("three").Vector3;
            lookAt(vector: number | import("three").Vector3, y?: number, z?: number): void;
            add(...object: Object3D<import("three").Event>[]): any;
            remove(...object: Object3D<import("three").Event>[]): any;
            removeFromParent(): any;
            clear(): any;
            attach(object: Object3D<import("three").Event>): any;
            getObjectById(id: number): Object3D<import("three").Event>;
            getObjectByName(name: string): Object3D<import("three").Event>;
            getObjectByProperty(name: string, value: string): Object3D<import("three").Event>;
            getWorldPosition(target: import("three").Vector3): import("three").Vector3;
            getWorldQuaternion(target: import("three").Quaternion): import("three").Quaternion;
            getWorldScale(target: import("three").Vector3): import("three").Vector3;
            getWorldDirection(target: import("three").Vector3): import("three").Vector3;
            raycast(raycaster: import("three").Raycaster, intersects: import("three").Intersection<Object3D<import("three").Event>>[]): void;
            traverse(callback: (object: Object3D<import("three").Event>) => any): void;
            traverseVisible(callback: (object: Object3D<import("three").Event>) => any): void;
            traverseAncestors(callback: (object: Object3D<import("three").Event>) => any): void;
            updateMatrix(): void;
            updateMatrixWorld(force?: boolean): void;
            updateWorldMatrix(updateParents: boolean, updateChildren: boolean): void;
            toJSON(meta?: {
                geometries: any;
                materials: any;
                textures: any;
                images: any;
            }): any;
            clone(recursive?: boolean): any;
            copy(source: any, recursive?: boolean): any;
            addEventListener<T_3 extends string>(type: T_3, listener: import("three").EventListener<import("three").Event, T_3, any>): void;
            hasEventListener<T_4 extends string>(type: T_4, listener: import("three").EventListener<import("three").Event, T_4, any>): boolean;
            removeEventListener<T_5 extends string>(type: T_5, listener: import("three").EventListener<import("three").Event, T_5, any>): void;
            dispatchEvent(event: import("three").Event): void;
        };
        _border: {
            _helpersSlice: any;
            _visible: boolean;
            _color: number;
            _material: import("three").LineBasicMaterial;
            _geometry: import("three").BufferGeometry;
            _mesh: import("three").Line<import("three").BufferGeometry, import("three").LineBasicMaterial>;
            helpersSlice: any;
            visible: boolean;
            color: number;
            _create(): void;
            _update(): void;
            dispose(): void;
            id: number;
            uuid: string;
            name: string;
            type: string;
            parent: Object3D<import("three").Event>;
            children: Object3D<import("three").Event>[];
            up: import("three").Vector3;
            readonly position: import("three").Vector3;
            readonly rotation: import("three").Euler;
            readonly quaternion: import("three").Quaternion;
            readonly scale: import("three").Vector3;
            readonly modelViewMatrix: import("three").Matrix4;
            readonly normalMatrix: import("three").Matrix3;
            matrix: import("three").Matrix4;
            matrixWorld: import("three").Matrix4;
            matrixAutoUpdate: boolean;
            matrixWorldNeedsUpdate: boolean;
            layers: import("three").Layers;
            castShadow: boolean;
            receiveShadow: boolean;
            frustumCulled: boolean;
            renderOrder: number;
            animations: import("three").AnimationClip[];
            userData: {
                [key: string]: any;
            };
            customDepthMaterial: import("three").Material;
            customDistanceMaterial: import("three").Material;
            readonly isObject3D: true;
            onBeforeRender: (renderer: import("three").WebGLRenderer, scene: import("three").Scene, camera: import("three").Camera, geometry: import("three").BufferGeometry, material: import("three").Material, group: import("three").Group) => void;
            onAfterRender: (renderer: import("three").WebGLRenderer, scene: import("three").Scene, camera: import("three").Camera, geometry: import("three").BufferGeometry, material: import("three").Material, group: import("three").Group) => void;
            applyMatrix4(matrix: import("three").Matrix4): void;
            applyQuaternion(quaternion: import("three").Quaternion): any;
            setRotationFromAxisAngle(axis: import("three").Vector3, angle: number): void;
            setRotationFromEuler(euler: import("three").Euler): void;
            setRotationFromMatrix(m: import("three").Matrix4): void;
            setRotationFromQuaternion(q: import("three").Quaternion): void;
            rotateOnAxis(axis: import("three").Vector3, angle: number): any;
            rotateOnWorldAxis(axis: import("three").Vector3, angle: number): any;
            rotateX(angle: number): any;
            rotateY(angle: number): any;
            rotateZ(angle: number): any;
            translateOnAxis(axis: import("three").Vector3, distance: number): any;
            translateX(distance: number): any;
            translateY(distance: number): any;
            translateZ(distance: number): any;
            localToWorld(vector: import("three").Vector3): import("three").Vector3;
            worldToLocal(vector: import("three").Vector3): import("three").Vector3;
            lookAt(vector: number | import("three").Vector3, y?: number, z?: number): void;
            add(...object: Object3D<import("three").Event>[]): any;
            remove(...object: Object3D<import("three").Event>[]): any;
            removeFromParent(): any;
            clear(): any;
            attach(object: Object3D<import("three").Event>): any;
            getObjectById(id: number): Object3D<import("three").Event>;
            getObjectByName(name: string): Object3D<import("three").Event>;
            getObjectByProperty(name: string, value: string): Object3D<import("three").Event>;
            getWorldPosition(target: import("three").Vector3): import("three").Vector3;
            getWorldQuaternion(target: import("three").Quaternion): import("three").Quaternion;
            getWorldScale(target: import("three").Vector3): import("three").Vector3;
            getWorldDirection(target: import("three").Vector3): import("three").Vector3;
            raycast(raycaster: import("three").Raycaster, intersects: import("three").Intersection<Object3D<import("three").Event>>[]): void;
            traverse(callback: (object: Object3D<import("three").Event>) => any): void;
            traverseVisible(callback: (object: Object3D<import("three").Event>) => any): void;
            traverseAncestors(callback: (object: Object3D<import("three").Event>) => any): void;
            updateMatrix(): void;
            updateMatrixWorld(force?: boolean): void;
            updateWorldMatrix(updateParents: boolean, updateChildren: boolean): void;
            toJSON(meta?: {
                geometries: any;
                materials: any;
                textures: any;
                images: any;
            }): any;
            clone(recursive?: boolean): any;
            copy(source: any, recursive?: boolean): any;
            addEventListener<T_6 extends string>(type: T_6, listener: import("three").EventListener<import("three").Event, T_6, any>): void;
            hasEventListener<T_7 extends string>(type: T_7, listener: import("three").EventListener<import("three").Event, T_7, any>): boolean;
            removeEventListener<T_8 extends string>(type: T_8, listener: import("three").EventListener<import("three").Event, T_8, any>): void;
            dispatchEvent(event: import("three").Event): void;
        };
        _dummy: any;
        _orientation: number;
        _index: number;
        _uniforms: any;
        _autoWindowLevel: boolean;
        _outOfBounds: boolean;
        _orientationMaxIndex: number;
        _orientationSpacing: number;
        _canvasWidth: number;
        _canvasHeight: number;
        _borderColor: any;
        stack: ModelsStack;
        readonly bbox: HelpersBoundingBox;
        readonly slice: HelpersSlice;
        readonly border: HelpersSlice;
        index: number;
        orientation: number;
        outOfBounds: boolean;
        orientationMaxIndex: number;
        orientationSpacing: number;
        canvasWidth: number;
        canvasHeight: number;
        borderColor: any;
        _create(): void;
        _computeOrientationSpacing(): void;
        _computeOrientationMaxIndex(): void;
        _isIndexOutOfBounds(): void;
        _prepareStack(): void;
        _prepareBBox(): void;
        _prepareBorder(): void;
        _prepareSlice(): void;
        _prepareSliceIndex(indices: import("three").Vector3): number;
        _prepareSlicePosition(rPosition: import("three").Vector3, index: number): number;
        _prepareDirection(orientation: number): import("three").Vector3;
        dispose(): void;
        id: number;
        uuid: string;
        name: string;
        type: string;
        parent: Object3D<import("three").Event>;
        children: Object3D<import("three").Event>[];
        up: import("three").Vector3;
        readonly position: import("three").Vector3;
        readonly rotation: import("three").Euler;
        readonly quaternion: import("three").Quaternion;
        readonly scale: import("three").Vector3;
        readonly modelViewMatrix: import("three").Matrix4;
        readonly normalMatrix: import("three").Matrix3;
        matrix: import("three").Matrix4;
        matrixWorld: import("three").Matrix4;
        matrixAutoUpdate: boolean;
        matrixWorldNeedsUpdate: boolean;
        layers: import("three").Layers;
        visible: boolean;
        castShadow: boolean;
        receiveShadow: boolean;
        frustumCulled: boolean;
        renderOrder: number;
        animations: import("three").AnimationClip[];
        userData: {
            [key: string]: any;
        };
        customDepthMaterial: import("three").Material;
        customDistanceMaterial: import("three").Material;
        readonly isObject3D: true;
        onBeforeRender: (renderer: import("three").WebGLRenderer, scene: import("three").Scene, camera: import("three").Camera, geometry: import("three").BufferGeometry, material: import("three").Material, group: import("three").Group) => void;
        onAfterRender: (renderer: import("three").WebGLRenderer, scene: import("three").Scene, camera: import("three").Camera, geometry: import("three").BufferGeometry, material: import("three").Material, group: import("three").Group) => void;
        applyMatrix4(matrix: import("three").Matrix4): void;
        applyQuaternion(quaternion: import("three").Quaternion): any;
        setRotationFromAxisAngle(axis: import("three").Vector3, angle: number): void;
        setRotationFromEuler(euler: import("three").Euler): void;
        setRotationFromMatrix(m: import("three").Matrix4): void;
        setRotationFromQuaternion(q: import("three").Quaternion): void;
        rotateOnAxis(axis: import("three").Vector3, angle: number): any;
        rotateOnWorldAxis(axis: import("three").Vector3, angle: number): any;
        rotateX(angle: number): any;
        rotateY(angle: number): any;
        rotateZ(angle: number): any;
        translateOnAxis(axis: import("three").Vector3, distance: number): any;
        translateX(distance: number): any;
        translateY(distance: number): any;
        translateZ(distance: number): any;
        localToWorld(vector: import("three").Vector3): import("three").Vector3;
        worldToLocal(vector: import("three").Vector3): import("three").Vector3;
        lookAt(vector: number | import("three").Vector3, y?: number, z?: number): void;
        add(...object: Object3D<import("three").Event>[]): any;
        remove(...object: Object3D<import("three").Event>[]): any;
        removeFromParent(): any;
        clear(): any;
        attach(object: Object3D<import("three").Event>): any;
        getObjectById(id: number): Object3D<import("three").Event>;
        getObjectByName(name: string): Object3D<import("three").Event>;
        getObjectByProperty(name: string, value: string): Object3D<import("three").Event>;
        getWorldPosition(target: import("three").Vector3): import("three").Vector3;
        getWorldQuaternion(target: import("three").Quaternion): import("three").Quaternion;
        getWorldScale(target: import("three").Vector3): import("three").Vector3;
        getWorldDirection(target: import("three").Vector3): import("three").Vector3;
        raycast(raycaster: import("three").Raycaster, intersects: import("three").Intersection<Object3D<import("three").Event>>[]): void;
        traverse(callback: (object: Object3D<import("three").Event>) => any): void;
        traverseVisible(callback: (object: Object3D<import("three").Event>) => any): void;
        traverseAncestors(callback: (object: Object3D<import("three").Event>) => any): void;
        updateMatrix(): void;
        updateMatrixWorld(force?: boolean): void;
        updateWorldMatrix(updateParents: boolean, updateChildren: boolean): void;
        toJSON(meta?: {
            geometries: any;
            materials: any;
            textures: any;
            images: any;
        }): any;
        clone(recursive?: boolean): any;
        copy(source: any, recursive?: boolean): any;
        addEventListener<T_9 extends string>(type: T_9, listener: import("three").EventListener<import("three").Event, T_9, any>): void;
        hasEventListener<T_10 extends string>(type: T_10, listener: import("three").EventListener<import("three").Event, T_10, any>): boolean;
        removeEventListener<T_11 extends string>(type: T_11, listener: import("three").EventListener<import("three").Event, T_11, any>): void;
        dispatchEvent(event: import("three").Event): void;
    };
    _ySlice: {
        _stack: any;
        _bBox: {
            _stack: any;
            _visible: boolean;
            _color: number;
            _material: import("three").Material | import("three").Material[] | import("three").MeshBasicMaterial;
            _geometry: import("three").BoxGeometry;
            _mesh: import("three").BoxHelper;
            _meshStack: import("three").Mesh<import("three").BoxGeometry, any>;
            visible: boolean;
            color: number;
            _create(): void;
            _update(): void;
            dispose(): void;
            id: number;
            uuid: string;
            name: string;
            type: string;
            parent: Object3D<import("three").Event>;
            children: Object3D<import("three").Event>[];
            up: import("three").Vector3;
            readonly position: import("three").Vector3;
            readonly rotation: import("three").Euler;
            readonly quaternion: import("three").Quaternion;
            readonly scale: import("three").Vector3;
            readonly modelViewMatrix: import("three").Matrix4;
            readonly normalMatrix: import("three").Matrix3;
            matrix: import("three").Matrix4;
            matrixWorld: import("three").Matrix4;
            matrixAutoUpdate: boolean;
            matrixWorldNeedsUpdate: boolean;
            layers: import("three").Layers;
            castShadow: boolean;
            receiveShadow: boolean;
            frustumCulled: boolean;
            renderOrder: number;
            animations: import("three").AnimationClip[];
            userData: {
                [key: string]: any;
            };
            customDepthMaterial: import("three").Material;
            customDistanceMaterial: import("three").Material;
            readonly isObject3D: true;
            onBeforeRender: (renderer: import("three").WebGLRenderer, scene: import("three").Scene, camera: import("three").Camera, geometry: import("three").BufferGeometry, material: import("three").Material, group: import("three").Group) => void;
            onAfterRender: (renderer: import("three").WebGLRenderer, scene: import("three").Scene, camera: import("three").Camera, geometry: import("three").BufferGeometry, material: import("three").Material, group: import("three").Group) => void;
            applyMatrix4(matrix: import("three").Matrix4): void;
            applyQuaternion(quaternion: import("three").Quaternion): any;
            setRotationFromAxisAngle(axis: import("three").Vector3, angle: number): void;
            setRotationFromEuler(euler: import("three").Euler): void;
            setRotationFromMatrix(m: import("three").Matrix4): void;
            setRotationFromQuaternion(q: import("three").Quaternion): void;
            rotateOnAxis(axis: import("three").Vector3, angle: number): any;
            rotateOnWorldAxis(axis: import("three").Vector3, angle: number): any;
            rotateX(angle: number): any;
            rotateY(angle: number): any;
            rotateZ(angle: number): any;
            translateOnAxis(axis: import("three").Vector3, distance: number): any;
            translateX(distance: number): any;
            translateY(distance: number): any;
            translateZ(distance: number): any;
            localToWorld(vector: import("three").Vector3): import("three").Vector3;
            worldToLocal(vector: import("three").Vector3): import("three").Vector3;
            lookAt(vector: number | import("three").Vector3, y?: number, z?: number): void;
            add(...object: Object3D<import("three").Event>[]): any;
            remove(...object: Object3D<import("three").Event>[]): any;
            removeFromParent(): any;
            clear(): any;
            attach(object: Object3D<import("three").Event>): any;
            getObjectById(id: number): Object3D<import("three").Event>;
            getObjectByName(name: string): Object3D<import("three").Event>;
            getObjectByProperty(name: string, value: string): Object3D<import("three").Event>;
            getWorldPosition(target: import("three").Vector3): import("three").Vector3;
            getWorldQuaternion(target: import("three").Quaternion): import("three").Quaternion;
            getWorldScale(target: import("three").Vector3): import("three").Vector3;
            getWorldDirection(target: import("three").Vector3): import("three").Vector3;
            raycast(raycaster: import("three").Raycaster, intersects: import("three").Intersection<Object3D<import("three").Event>>[]): void;
            traverse(callback: (object: Object3D<import("three").Event>) => any): void;
            traverseVisible(callback: (object: Object3D<import("three").Event>) => any): void;
            traverseAncestors(callback: (object: Object3D<import("three").Event>) => any): void;
            updateMatrix(): void;
            updateMatrixWorld(force?: boolean): void;
            updateWorldMatrix(updateParents: boolean, updateChildren: boolean): void;
            toJSON(meta?: {
                geometries: any;
                materials: any;
                textures: any;
                images: any;
            }): any;
            clone(recursive?: boolean): any;
            copy(source: any, recursive?: boolean): any;
            addEventListener<T extends string>(type: T, listener: import("three").EventListener<import("three").Event, T, any>): void;
            hasEventListener<T_1 extends string>(type: T_1, listener: import("three").EventListener<import("three").Event, T_1, any>): boolean;
            removeEventListener<T_2 extends string>(type: T_2, listener: import("three").EventListener<import("three").Event, T_2, any>): void;
            dispatchEvent(event: import("three").Event): void;
        };
        _slice: {
            _stack: any;
            _invert: any;
            _lut: string;
            _lutTexture: any;
            _intensityAuto: boolean;
            _interpolation: number;
            _index: number;
            _windowWidth: any;
            _windowCenter: any;
            _opacity: number;
            _rescaleSlope: any;
            _rescaleIntercept: any;
            _spacing: number;
            _thickness: number;
            _thicknessMethod: number;
            _lowerThreshold: any;
            _upperThreshold: any;
            _canvasWidth: number;
            _canvasHeight: number;
            _borderColor: any;
            _planePosition: import("three").Vector3;
            _planeDirection: import("three").Vector3;
            _aaBBspace: string;
            _material: import("three").ShaderMaterial;
            _textures: any[];
            _shadersFragment: typeof import("../../ami").DataFragmentShader;
            _shadersVertex: typeof import("../../ami").DataVertexShader;
            _uniforms: {
                uTextureSize: {
                    type: string;
                    value: number;
                    typeGLSL: string;
                };
                uTextureContainer: {
                    type: string;
                    value: any[];
                    typeGLSL: string;
                    length: number;
                };
                uDataDimensions: {
                    type: string;
                    value: number[];
                    typeGLSL: string;
                };
                uWorldToData: {
                    type: string;
                    value: import("three").Matrix4;
                    typeGLSL: string;
                };
                uWindowCenterWidth: {
                    type: string;
                    value: number[];
                    typeGLSL: string;
                    length: number;
                };
                uLowerUpperThreshold: {
                    type: string;
                    value: number[];
                    typeGLSL: string;
                    length: number;
                };
                uRescaleSlopeIntercept: {
                    type: string;
                    value: number[];
                    typeGLSL: string;
                    length: number;
                };
                uNumberOfChannels: {
                    type: string;
                    value: number;
                    typeGLSL: string;
                };
                uBitsAllocated: {
                    type: string;
                    value: number;
                    typeGLSL: string;
                };
                uInvert: {
                    type: string;
                    value: number;
                    typeGLSL: string;
                };
                uLut: {
                    type: string;
                    value: number;
                    typeGLSL: string;
                };
                uTextureLUT: {
                    type: string;
                    value: any[];
                    typeGLSL: string;
                };
                uLutSegmentation: {
                    type: string;
                    value: number;
                    typeGLSL: string;
                };
                uTextureLUTSegmentation: {
                    type: string;
                    value: any[];
                    typeGLSL: string;
                };
                uPixelType: {
                    type: string;
                    value: number;
                    typeGLSL: string;
                };
                uPackedPerPixel: {
                    type: string;
                    value: number;
                    typeGLSL: string;
                };
                uInterpolation: {
                    type: string;
                    value: number;
                    typeGLSL: string;
                };
                uCanvasWidth: {
                    type: string;
                    value: number;
                    typeGLSL: string;
                };
                uCanvasHeight: {
                    type: string;
                    value: number;
                    typeGLSL: string;
                };
                uBorderColor: {
                    type: string;
                    value: number[];
                    typeGLSL: string;
                };
                uBorderWidth: {
                    type: string;
                    value: number;
                    typeGLSL: string;
                };
                uBorderMargin: {
                    type: string;
                    value: number;
                    typeGLSL: string;
                };
                uBorderDashLength: {
                    type: string;
                    value: number;
                    typeGLSL: string;
                };
                uOpacity: {
                    type: string;
                    value: number;
                    typeGLSL: string;
                };
                uSpacing: {
                    type: string;
                    value: number;
                    typeGLSL: string;
                };
                uThickness: {
                    type: string;
                    value: number;
                    typeGLSL: string;
                };
                uThicknessMethod: {
                    type: string;
                    value: number;
                    typeGLSL: string;
                };
            };
            _geometry: any;
            _mesh: any;
            _visible: boolean;
            stack: any;
            spacing: number;
            thickness: number;
            thicknessMethod: number;
            windowWidth: any;
            windowCenter: any;
            opacity: number;
            upperThreshold: any;
            lowerThreshold: any;
            rescaleSlope: any;
            rescaleIntercept: any;
            invert: any;
            lut: string;
            lutTexture: any;
            intensityAuto: boolean;
            interpolation: number;
            index: number;
            planePosition: import("three").Vector3;
            planeDirection: import("three").Vector3;
            halfDimensions: any;
            _halfDimensions: any;
            center: any;
            _center: any;
            aabbSpace: string;
            mesh: any;
            geometry: any;
            canvasWidth: number;
            canvasHeight: number;
            borderColor: any;
            _init(): void;
            _toAABB: any;
            _create(): void;
            updateIntensitySettings(): void;
            updateIntensitySettingsUniforms(): void;
            updateIntensitySetting(setting: any): void;
            _update(): void;
            dispose(): void;
            cartesianEquation(): import("three").Vector4;
            _createMaterial(extraOptions: any): void;
            _updateMaterial(): void;
            _prepareTexture(): void;
            id: number;
            uuid: string;
            name: string;
            type: string;
            parent: Object3D<import("three").Event>;
            children: Object3D<import("three").Event>[];
            up: import("three").Vector3;
            readonly position: import("three").Vector3;
            readonly rotation: import("three").Euler;
            readonly quaternion: import("three").Quaternion;
            readonly scale: import("three").Vector3;
            readonly modelViewMatrix: import("three").Matrix4;
            readonly normalMatrix: import("three").Matrix3;
            matrix: import("three").Matrix4;
            matrixWorld: import("three").Matrix4;
            matrixAutoUpdate: boolean;
            matrixWorldNeedsUpdate: boolean;
            layers: import("three").Layers;
            visible: boolean;
            castShadow: boolean;
            receiveShadow: boolean;
            frustumCulled: boolean;
            renderOrder: number;
            animations: import("three").AnimationClip[];
            userData: {
                [key: string]: any;
            };
            customDepthMaterial: import("three").Material;
            customDistanceMaterial: import("three").Material;
            readonly isObject3D: true;
            onBeforeRender: (renderer: import("three").WebGLRenderer, scene: import("three").Scene, camera: import("three").Camera, geometry: import("three").BufferGeometry, material: import("three").Material, group: import("three").Group) => void;
            onAfterRender: (renderer: import("three").WebGLRenderer, scene: import("three").Scene, camera: import("three").Camera, geometry: import("three").BufferGeometry, material: import("three").Material, group: import("three").Group) => void;
            applyMatrix4(matrix: import("three").Matrix4): void;
            applyQuaternion(quaternion: import("three").Quaternion): any;
            setRotationFromAxisAngle(axis: import("three").Vector3, angle: number): void;
            setRotationFromEuler(euler: import("three").Euler): void;
            setRotationFromMatrix(m: import("three").Matrix4): void;
            setRotationFromQuaternion(q: import("three").Quaternion): void;
            rotateOnAxis(axis: import("three").Vector3, angle: number): any;
            rotateOnWorldAxis(axis: import("three").Vector3, angle: number): any;
            rotateX(angle: number): any;
            rotateY(angle: number): any;
            rotateZ(angle: number): any;
            translateOnAxis(axis: import("three").Vector3, distance: number): any;
            translateX(distance: number): any;
            translateY(distance: number): any;
            translateZ(distance: number): any;
            localToWorld(vector: import("three").Vector3): import("three").Vector3;
            worldToLocal(vector: import("three").Vector3): import("three").Vector3;
            lookAt(vector: number | import("three").Vector3, y?: number, z?: number): void;
            add(...object: Object3D<import("three").Event>[]): any;
            remove(...object: Object3D<import("three").Event>[]): any;
            removeFromParent(): any;
            clear(): any;
            attach(object: Object3D<import("three").Event>): any;
            getObjectById(id: number): Object3D<import("three").Event>;
            getObjectByName(name: string): Object3D<import("three").Event>;
            getObjectByProperty(name: string, value: string): Object3D<import("three").Event>;
            getWorldPosition(target: import("three").Vector3): import("three").Vector3;
            getWorldQuaternion(target: import("three").Quaternion): import("three").Quaternion;
            getWorldScale(target: import("three").Vector3): import("three").Vector3;
            getWorldDirection(target: import("three").Vector3): import("three").Vector3;
            raycast(raycaster: import("three").Raycaster, intersects: import("three").Intersection<Object3D<import("three").Event>>[]): void;
            traverse(callback: (object: Object3D<import("three").Event>) => any): void;
            traverseVisible(callback: (object: Object3D<import("three").Event>) => any): void;
            traverseAncestors(callback: (object: Object3D<import("three").Event>) => any): void;
            updateMatrix(): void;
            updateMatrixWorld(force?: boolean): void;
            updateWorldMatrix(updateParents: boolean, updateChildren: boolean): void;
            toJSON(meta?: {
                geometries: any;
                materials: any;
                textures: any;
                images: any;
            }): any;
            clone(recursive?: boolean): any;
            copy(source: any, recursive?: boolean): any;
            addEventListener<T_3 extends string>(type: T_3, listener: import("three").EventListener<import("three").Event, T_3, any>): void;
            hasEventListener<T_4 extends string>(type: T_4, listener: import("three").EventListener<import("three").Event, T_4, any>): boolean;
            removeEventListener<T_5 extends string>(type: T_5, listener: import("three").EventListener<import("three").Event, T_5, any>): void;
            dispatchEvent(event: import("three").Event): void;
        };
        _border: {
            _helpersSlice: any;
            _visible: boolean;
            _color: number;
            _material: import("three").LineBasicMaterial;
            _geometry: import("three").BufferGeometry;
            _mesh: import("three").Line<import("three").BufferGeometry, import("three").LineBasicMaterial>;
            helpersSlice: any;
            visible: boolean;
            color: number;
            _create(): void;
            _update(): void;
            dispose(): void;
            id: number;
            uuid: string;
            name: string;
            type: string;
            parent: Object3D<import("three").Event>;
            children: Object3D<import("three").Event>[];
            up: import("three").Vector3;
            readonly position: import("three").Vector3;
            readonly rotation: import("three").Euler;
            readonly quaternion: import("three").Quaternion;
            readonly scale: import("three").Vector3;
            readonly modelViewMatrix: import("three").Matrix4;
            readonly normalMatrix: import("three").Matrix3;
            matrix: import("three").Matrix4;
            matrixWorld: import("three").Matrix4;
            matrixAutoUpdate: boolean;
            matrixWorldNeedsUpdate: boolean;
            layers: import("three").Layers;
            castShadow: boolean;
            receiveShadow: boolean;
            frustumCulled: boolean;
            renderOrder: number;
            animations: import("three").AnimationClip[];
            userData: {
                [key: string]: any;
            };
            customDepthMaterial: import("three").Material;
            customDistanceMaterial: import("three").Material;
            readonly isObject3D: true;
            onBeforeRender: (renderer: import("three").WebGLRenderer, scene: import("three").Scene, camera: import("three").Camera, geometry: import("three").BufferGeometry, material: import("three").Material, group: import("three").Group) => void;
            onAfterRender: (renderer: import("three").WebGLRenderer, scene: import("three").Scene, camera: import("three").Camera, geometry: import("three").BufferGeometry, material: import("three").Material, group: import("three").Group) => void;
            applyMatrix4(matrix: import("three").Matrix4): void;
            applyQuaternion(quaternion: import("three").Quaternion): any;
            setRotationFromAxisAngle(axis: import("three").Vector3, angle: number): void;
            setRotationFromEuler(euler: import("three").Euler): void;
            setRotationFromMatrix(m: import("three").Matrix4): void;
            setRotationFromQuaternion(q: import("three").Quaternion): void;
            rotateOnAxis(axis: import("three").Vector3, angle: number): any;
            rotateOnWorldAxis(axis: import("three").Vector3, angle: number): any;
            rotateX(angle: number): any;
            rotateY(angle: number): any;
            rotateZ(angle: number): any;
            translateOnAxis(axis: import("three").Vector3, distance: number): any;
            translateX(distance: number): any;
            translateY(distance: number): any;
            translateZ(distance: number): any;
            localToWorld(vector: import("three").Vector3): import("three").Vector3;
            worldToLocal(vector: import("three").Vector3): import("three").Vector3;
            lookAt(vector: number | import("three").Vector3, y?: number, z?: number): void;
            add(...object: Object3D<import("three").Event>[]): any;
            remove(...object: Object3D<import("three").Event>[]): any;
            removeFromParent(): any;
            clear(): any;
            attach(object: Object3D<import("three").Event>): any;
            getObjectById(id: number): Object3D<import("three").Event>;
            getObjectByName(name: string): Object3D<import("three").Event>;
            getObjectByProperty(name: string, value: string): Object3D<import("three").Event>;
            getWorldPosition(target: import("three").Vector3): import("three").Vector3;
            getWorldQuaternion(target: import("three").Quaternion): import("three").Quaternion;
            getWorldScale(target: import("three").Vector3): import("three").Vector3;
            getWorldDirection(target: import("three").Vector3): import("three").Vector3;
            raycast(raycaster: import("three").Raycaster, intersects: import("three").Intersection<Object3D<import("three").Event>>[]): void;
            traverse(callback: (object: Object3D<import("three").Event>) => any): void;
            traverseVisible(callback: (object: Object3D<import("three").Event>) => any): void;
            traverseAncestors(callback: (object: Object3D<import("three").Event>) => any): void;
            updateMatrix(): void;
            updateMatrixWorld(force?: boolean): void;
            updateWorldMatrix(updateParents: boolean, updateChildren: boolean): void;
            toJSON(meta?: {
                geometries: any;
                materials: any;
                textures: any;
                images: any;
            }): any;
            clone(recursive?: boolean): any;
            copy(source: any, recursive?: boolean): any;
            addEventListener<T_6 extends string>(type: T_6, listener: import("three").EventListener<import("three").Event, T_6, any>): void;
            hasEventListener<T_7 extends string>(type: T_7, listener: import("three").EventListener<import("three").Event, T_7, any>): boolean;
            removeEventListener<T_8 extends string>(type: T_8, listener: import("three").EventListener<import("three").Event, T_8, any>): void;
            dispatchEvent(event: import("three").Event): void;
        };
        _dummy: any;
        _orientation: number;
        _index: number;
        _uniforms: any;
        _autoWindowLevel: boolean;
        _outOfBounds: boolean;
        _orientationMaxIndex: number;
        _orientationSpacing: number;
        _canvasWidth: number;
        _canvasHeight: number;
        _borderColor: any;
        stack: ModelsStack;
        readonly bbox: HelpersBoundingBox;
        readonly slice: HelpersSlice;
        readonly border: HelpersSlice;
        index: number;
        orientation: number;
        outOfBounds: boolean;
        orientationMaxIndex: number;
        orientationSpacing: number;
        canvasWidth: number;
        canvasHeight: number;
        borderColor: any;
        _create(): void;
        _computeOrientationSpacing(): void;
        _computeOrientationMaxIndex(): void;
        _isIndexOutOfBounds(): void;
        _prepareStack(): void;
        _prepareBBox(): void;
        _prepareBorder(): void;
        _prepareSlice(): void;
        _prepareSliceIndex(indices: import("three").Vector3): number;
        _prepareSlicePosition(rPosition: import("three").Vector3, index: number): number;
        _prepareDirection(orientation: number): import("three").Vector3;
        dispose(): void;
        id: number;
        uuid: string;
        name: string;
        type: string;
        parent: Object3D<import("three").Event>;
        children: Object3D<import("three").Event>[];
        up: import("three").Vector3;
        readonly position: import("three").Vector3;
        readonly rotation: import("three").Euler;
        readonly quaternion: import("three").Quaternion;
        readonly scale: import("three").Vector3;
        readonly modelViewMatrix: import("three").Matrix4;
        readonly normalMatrix: import("three").Matrix3;
        matrix: import("three").Matrix4;
        matrixWorld: import("three").Matrix4;
        matrixAutoUpdate: boolean;
        matrixWorldNeedsUpdate: boolean;
        layers: import("three").Layers;
        visible: boolean;
        castShadow: boolean;
        receiveShadow: boolean;
        frustumCulled: boolean;
        renderOrder: number;
        animations: import("three").AnimationClip[];
        userData: {
            [key: string]: any;
        };
        customDepthMaterial: import("three").Material;
        customDistanceMaterial: import("three").Material;
        readonly isObject3D: true;
        onBeforeRender: (renderer: import("three").WebGLRenderer, scene: import("three").Scene, camera: import("three").Camera, geometry: import("three").BufferGeometry, material: import("three").Material, group: import("three").Group) => void;
        onAfterRender: (renderer: import("three").WebGLRenderer, scene: import("three").Scene, camera: import("three").Camera, geometry: import("three").BufferGeometry, material: import("three").Material, group: import("three").Group) => void;
        applyMatrix4(matrix: import("three").Matrix4): void;
        applyQuaternion(quaternion: import("three").Quaternion): any;
        setRotationFromAxisAngle(axis: import("three").Vector3, angle: number): void;
        setRotationFromEuler(euler: import("three").Euler): void;
        setRotationFromMatrix(m: import("three").Matrix4): void;
        setRotationFromQuaternion(q: import("three").Quaternion): void;
        rotateOnAxis(axis: import("three").Vector3, angle: number): any;
        rotateOnWorldAxis(axis: import("three").Vector3, angle: number): any;
        rotateX(angle: number): any;
        rotateY(angle: number): any;
        rotateZ(angle: number): any;
        translateOnAxis(axis: import("three").Vector3, distance: number): any;
        translateX(distance: number): any;
        translateY(distance: number): any;
        translateZ(distance: number): any;
        localToWorld(vector: import("three").Vector3): import("three").Vector3;
        worldToLocal(vector: import("three").Vector3): import("three").Vector3;
        lookAt(vector: number | import("three").Vector3, y?: number, z?: number): void;
        add(...object: Object3D<import("three").Event>[]): any;
        remove(...object: Object3D<import("three").Event>[]): any;
        removeFromParent(): any;
        clear(): any;
        attach(object: Object3D<import("three").Event>): any;
        getObjectById(id: number): Object3D<import("three").Event>;
        getObjectByName(name: string): Object3D<import("three").Event>;
        getObjectByProperty(name: string, value: string): Object3D<import("three").Event>;
        getWorldPosition(target: import("three").Vector3): import("three").Vector3;
        getWorldQuaternion(target: import("three").Quaternion): import("three").Quaternion;
        getWorldScale(target: import("three").Vector3): import("three").Vector3;
        getWorldDirection(target: import("three").Vector3): import("three").Vector3;
        raycast(raycaster: import("three").Raycaster, intersects: import("three").Intersection<Object3D<import("three").Event>>[]): void;
        traverse(callback: (object: Object3D<import("three").Event>) => any): void;
        traverseVisible(callback: (object: Object3D<import("three").Event>) => any): void;
        traverseAncestors(callback: (object: Object3D<import("three").Event>) => any): void;
        updateMatrix(): void;
        updateMatrixWorld(force?: boolean): void;
        updateWorldMatrix(updateParents: boolean, updateChildren: boolean): void;
        toJSON(meta?: {
            geometries: any;
            materials: any;
            textures: any;
            images: any;
        }): any;
        clone(recursive?: boolean): any;
        copy(source: any, recursive?: boolean): any;
        addEventListener<T_9 extends string>(type: T_9, listener: import("three").EventListener<import("three").Event, T_9, any>): void;
        hasEventListener<T_10 extends string>(type: T_10, listener: import("three").EventListener<import("three").Event, T_10, any>): boolean;
        removeEventListener<T_11 extends string>(type: T_11, listener: import("three").EventListener<import("three").Event, T_11, any>): void;
        dispatchEvent(event: import("three").Event): void;
    };
    _zSlice: {
        _stack: any;
        _bBox: {
            _stack: any;
            _visible: boolean;
            _color: number;
            _material: import("three").Material | import("three").Material[] | import("three").MeshBasicMaterial;
            _geometry: import("three").BoxGeometry;
            _mesh: import("three").BoxHelper;
            _meshStack: import("three").Mesh<import("three").BoxGeometry, any>;
            visible: boolean;
            color: number;
            _create(): void;
            _update(): void;
            dispose(): void;
            id: number;
            uuid: string;
            name: string;
            type: string;
            parent: Object3D<import("three").Event>;
            children: Object3D<import("three").Event>[];
            up: import("three").Vector3;
            readonly position: import("three").Vector3;
            readonly rotation: import("three").Euler;
            readonly quaternion: import("three").Quaternion;
            readonly scale: import("three").Vector3;
            readonly modelViewMatrix: import("three").Matrix4;
            readonly normalMatrix: import("three").Matrix3;
            matrix: import("three").Matrix4;
            matrixWorld: import("three").Matrix4;
            matrixAutoUpdate: boolean;
            matrixWorldNeedsUpdate: boolean;
            layers: import("three").Layers;
            castShadow: boolean;
            receiveShadow: boolean;
            frustumCulled: boolean;
            renderOrder: number;
            animations: import("three").AnimationClip[];
            userData: {
                [key: string]: any;
            };
            customDepthMaterial: import("three").Material;
            customDistanceMaterial: import("three").Material;
            readonly isObject3D: true;
            onBeforeRender: (renderer: import("three").WebGLRenderer, scene: import("three").Scene, camera: import("three").Camera, geometry: import("three").BufferGeometry, material: import("three").Material, group: import("three").Group) => void;
            onAfterRender: (renderer: import("three").WebGLRenderer, scene: import("three").Scene, camera: import("three").Camera, geometry: import("three").BufferGeometry, material: import("three").Material, group: import("three").Group) => void;
            applyMatrix4(matrix: import("three").Matrix4): void;
            applyQuaternion(quaternion: import("three").Quaternion): any;
            setRotationFromAxisAngle(axis: import("three").Vector3, angle: number): void;
            setRotationFromEuler(euler: import("three").Euler): void;
            setRotationFromMatrix(m: import("three").Matrix4): void;
            setRotationFromQuaternion(q: import("three").Quaternion): void;
            rotateOnAxis(axis: import("three").Vector3, angle: number): any;
            rotateOnWorldAxis(axis: import("three").Vector3, angle: number): any;
            rotateX(angle: number): any;
            rotateY(angle: number): any;
            rotateZ(angle: number): any;
            translateOnAxis(axis: import("three").Vector3, distance: number): any;
            translateX(distance: number): any;
            translateY(distance: number): any;
            translateZ(distance: number): any;
            localToWorld(vector: import("three").Vector3): import("three").Vector3;
            worldToLocal(vector: import("three").Vector3): import("three").Vector3;
            lookAt(vector: number | import("three").Vector3, y?: number, z?: number): void;
            add(...object: Object3D<import("three").Event>[]): any;
            remove(...object: Object3D<import("three").Event>[]): any;
            removeFromParent(): any;
            clear(): any;
            attach(object: Object3D<import("three").Event>): any;
            getObjectById(id: number): Object3D<import("three").Event>;
            getObjectByName(name: string): Object3D<import("three").Event>;
            getObjectByProperty(name: string, value: string): Object3D<import("three").Event>;
            getWorldPosition(target: import("three").Vector3): import("three").Vector3;
            getWorldQuaternion(target: import("three").Quaternion): import("three").Quaternion;
            getWorldScale(target: import("three").Vector3): import("three").Vector3;
            getWorldDirection(target: import("three").Vector3): import("three").Vector3;
            raycast(raycaster: import("three").Raycaster, intersects: import("three").Intersection<Object3D<import("three").Event>>[]): void;
            traverse(callback: (object: Object3D<import("three").Event>) => any): void;
            traverseVisible(callback: (object: Object3D<import("three").Event>) => any): void;
            traverseAncestors(callback: (object: Object3D<import("three").Event>) => any): void;
            updateMatrix(): void;
            updateMatrixWorld(force?: boolean): void;
            updateWorldMatrix(updateParents: boolean, updateChildren: boolean): void;
            toJSON(meta?: {
                geometries: any;
                materials: any;
                textures: any;
                images: any;
            }): any;
            clone(recursive?: boolean): any;
            copy(source: any, recursive?: boolean): any;
            addEventListener<T extends string>(type: T, listener: import("three").EventListener<import("three").Event, T, any>): void;
            hasEventListener<T_1 extends string>(type: T_1, listener: import("three").EventListener<import("three").Event, T_1, any>): boolean;
            removeEventListener<T_2 extends string>(type: T_2, listener: import("three").EventListener<import("three").Event, T_2, any>): void;
            dispatchEvent(event: import("three").Event): void;
        };
        _slice: {
            _stack: any;
            _invert: any;
            _lut: string;
            _lutTexture: any;
            _intensityAuto: boolean;
            _interpolation: number;
            _index: number;
            _windowWidth: any;
            _windowCenter: any;
            _opacity: number;
            _rescaleSlope: any;
            _rescaleIntercept: any;
            _spacing: number;
            _thickness: number;
            _thicknessMethod: number;
            _lowerThreshold: any;
            _upperThreshold: any;
            _canvasWidth: number;
            _canvasHeight: number;
            _borderColor: any;
            _planePosition: import("three").Vector3;
            _planeDirection: import("three").Vector3;
            _aaBBspace: string;
            _material: import("three").ShaderMaterial;
            _textures: any[];
            _shadersFragment: typeof import("../../ami").DataFragmentShader;
            _shadersVertex: typeof import("../../ami").DataVertexShader;
            _uniforms: {
                uTextureSize: {
                    type: string;
                    value: number;
                    typeGLSL: string;
                };
                uTextureContainer: {
                    type: string;
                    value: any[];
                    typeGLSL: string;
                    length: number;
                };
                uDataDimensions: {
                    type: string;
                    value: number[];
                    typeGLSL: string;
                };
                uWorldToData: {
                    type: string;
                    value: import("three").Matrix4;
                    typeGLSL: string;
                };
                uWindowCenterWidth: {
                    type: string;
                    value: number[];
                    typeGLSL: string;
                    length: number;
                };
                uLowerUpperThreshold: {
                    type: string;
                    value: number[];
                    typeGLSL: string;
                    length: number;
                };
                uRescaleSlopeIntercept: {
                    type: string;
                    value: number[];
                    typeGLSL: string;
                    length: number;
                };
                uNumberOfChannels: {
                    type: string;
                    value: number;
                    typeGLSL: string;
                };
                uBitsAllocated: {
                    type: string;
                    value: number;
                    typeGLSL: string;
                };
                uInvert: {
                    type: string;
                    value: number;
                    typeGLSL: string;
                };
                uLut: {
                    type: string;
                    value: number;
                    typeGLSL: string;
                };
                uTextureLUT: {
                    type: string;
                    value: any[];
                    typeGLSL: string;
                };
                uLutSegmentation: {
                    type: string;
                    value: number;
                    typeGLSL: string;
                };
                uTextureLUTSegmentation: {
                    type: string;
                    value: any[];
                    typeGLSL: string;
                };
                uPixelType: {
                    type: string;
                    value: number;
                    typeGLSL: string;
                };
                uPackedPerPixel: {
                    type: string;
                    value: number;
                    typeGLSL: string;
                };
                uInterpolation: {
                    type: string;
                    value: number;
                    typeGLSL: string;
                };
                uCanvasWidth: {
                    type: string;
                    value: number;
                    typeGLSL: string;
                };
                uCanvasHeight: {
                    type: string;
                    value: number;
                    typeGLSL: string;
                };
                uBorderColor: {
                    type: string;
                    value: number[];
                    typeGLSL: string;
                };
                uBorderWidth: {
                    type: string;
                    value: number;
                    typeGLSL: string;
                };
                uBorderMargin: {
                    type: string;
                    value: number;
                    typeGLSL: string;
                };
                uBorderDashLength: {
                    type: string;
                    value: number;
                    typeGLSL: string;
                };
                uOpacity: {
                    type: string;
                    value: number;
                    typeGLSL: string;
                };
                uSpacing: {
                    type: string;
                    value: number;
                    typeGLSL: string;
                };
                uThickness: {
                    type: string;
                    value: number;
                    typeGLSL: string;
                };
                uThicknessMethod: {
                    type: string;
                    value: number;
                    typeGLSL: string;
                };
            };
            _geometry: any;
            _mesh: any;
            _visible: boolean;
            stack: any;
            spacing: number;
            thickness: number;
            thicknessMethod: number;
            windowWidth: any;
            windowCenter: any;
            opacity: number;
            upperThreshold: any;
            lowerThreshold: any;
            rescaleSlope: any;
            rescaleIntercept: any;
            invert: any;
            lut: string;
            lutTexture: any;
            intensityAuto: boolean;
            interpolation: number;
            index: number;
            planePosition: import("three").Vector3;
            planeDirection: import("three").Vector3;
            halfDimensions: any;
            _halfDimensions: any;
            center: any;
            _center: any;
            aabbSpace: string;
            mesh: any;
            geometry: any;
            canvasWidth: number;
            canvasHeight: number;
            borderColor: any;
            _init(): void;
            _toAABB: any;
            _create(): void;
            updateIntensitySettings(): void;
            updateIntensitySettingsUniforms(): void;
            updateIntensitySetting(setting: any): void;
            _update(): void;
            dispose(): void;
            cartesianEquation(): import("three").Vector4;
            _createMaterial(extraOptions: any): void;
            _updateMaterial(): void;
            _prepareTexture(): void;
            id: number;
            uuid: string;
            name: string;
            type: string;
            parent: Object3D<import("three").Event>;
            children: Object3D<import("three").Event>[];
            up: import("three").Vector3;
            readonly position: import("three").Vector3;
            readonly rotation: import("three").Euler;
            readonly quaternion: import("three").Quaternion;
            readonly scale: import("three").Vector3;
            readonly modelViewMatrix: import("three").Matrix4;
            readonly normalMatrix: import("three").Matrix3;
            matrix: import("three").Matrix4;
            matrixWorld: import("three").Matrix4;
            matrixAutoUpdate: boolean;
            matrixWorldNeedsUpdate: boolean;
            layers: import("three").Layers;
            visible: boolean;
            castShadow: boolean;
            receiveShadow: boolean;
            frustumCulled: boolean;
            renderOrder: number;
            animations: import("three").AnimationClip[];
            userData: {
                [key: string]: any;
            };
            customDepthMaterial: import("three").Material;
            customDistanceMaterial: import("three").Material;
            readonly isObject3D: true;
            onBeforeRender: (renderer: import("three").WebGLRenderer, scene: import("three").Scene, camera: import("three").Camera, geometry: import("three").BufferGeometry, material: import("three").Material, group: import("three").Group) => void;
            onAfterRender: (renderer: import("three").WebGLRenderer, scene: import("three").Scene, camera: import("three").Camera, geometry: import("three").BufferGeometry, material: import("three").Material, group: import("three").Group) => void;
            applyMatrix4(matrix: import("three").Matrix4): void;
            applyQuaternion(quaternion: import("three").Quaternion): any;
            setRotationFromAxisAngle(axis: import("three").Vector3, angle: number): void;
            setRotationFromEuler(euler: import("three").Euler): void;
            setRotationFromMatrix(m: import("three").Matrix4): void;
            setRotationFromQuaternion(q: import("three").Quaternion): void;
            rotateOnAxis(axis: import("three").Vector3, angle: number): any;
            rotateOnWorldAxis(axis: import("three").Vector3, angle: number): any;
            rotateX(angle: number): any;
            rotateY(angle: number): any;
            rotateZ(angle: number): any;
            translateOnAxis(axis: import("three").Vector3, distance: number): any;
            translateX(distance: number): any;
            translateY(distance: number): any;
            translateZ(distance: number): any;
            localToWorld(vector: import("three").Vector3): import("three").Vector3;
            worldToLocal(vector: import("three").Vector3): import("three").Vector3;
            lookAt(vector: number | import("three").Vector3, y?: number, z?: number): void;
            add(...object: Object3D<import("three").Event>[]): any;
            remove(...object: Object3D<import("three").Event>[]): any;
            removeFromParent(): any;
            clear(): any;
            attach(object: Object3D<import("three").Event>): any;
            getObjectById(id: number): Object3D<import("three").Event>;
            getObjectByName(name: string): Object3D<import("three").Event>;
            getObjectByProperty(name: string, value: string): Object3D<import("three").Event>;
            getWorldPosition(target: import("three").Vector3): import("three").Vector3;
            getWorldQuaternion(target: import("three").Quaternion): import("three").Quaternion;
            getWorldScale(target: import("three").Vector3): import("three").Vector3;
            getWorldDirection(target: import("three").Vector3): import("three").Vector3;
            raycast(raycaster: import("three").Raycaster, intersects: import("three").Intersection<Object3D<import("three").Event>>[]): void;
            traverse(callback: (object: Object3D<import("three").Event>) => any): void;
            traverseVisible(callback: (object: Object3D<import("three").Event>) => any): void;
            traverseAncestors(callback: (object: Object3D<import("three").Event>) => any): void;
            updateMatrix(): void;
            updateMatrixWorld(force?: boolean): void;
            updateWorldMatrix(updateParents: boolean, updateChildren: boolean): void;
            toJSON(meta?: {
                geometries: any;
                materials: any;
                textures: any;
                images: any;
            }): any;
            clone(recursive?: boolean): any;
            copy(source: any, recursive?: boolean): any;
            addEventListener<T_3 extends string>(type: T_3, listener: import("three").EventListener<import("three").Event, T_3, any>): void;
            hasEventListener<T_4 extends string>(type: T_4, listener: import("three").EventListener<import("three").Event, T_4, any>): boolean;
            removeEventListener<T_5 extends string>(type: T_5, listener: import("three").EventListener<import("three").Event, T_5, any>): void;
            dispatchEvent(event: import("three").Event): void;
        };
        _border: {
            _helpersSlice: any;
            _visible: boolean;
            _color: number;
            _material: import("three").LineBasicMaterial;
            _geometry: import("three").BufferGeometry;
            _mesh: import("three").Line<import("three").BufferGeometry, import("three").LineBasicMaterial>;
            helpersSlice: any;
            visible: boolean;
            color: number;
            _create(): void;
            _update(): void;
            dispose(): void;
            id: number;
            uuid: string;
            name: string;
            type: string;
            parent: Object3D<import("three").Event>;
            children: Object3D<import("three").Event>[];
            up: import("three").Vector3;
            readonly position: import("three").Vector3;
            readonly rotation: import("three").Euler;
            readonly quaternion: import("three").Quaternion;
            readonly scale: import("three").Vector3;
            readonly modelViewMatrix: import("three").Matrix4;
            readonly normalMatrix: import("three").Matrix3;
            matrix: import("three").Matrix4;
            matrixWorld: import("three").Matrix4;
            matrixAutoUpdate: boolean;
            matrixWorldNeedsUpdate: boolean;
            layers: import("three").Layers;
            castShadow: boolean;
            receiveShadow: boolean;
            frustumCulled: boolean;
            renderOrder: number;
            animations: import("three").AnimationClip[];
            userData: {
                [key: string]: any;
            };
            customDepthMaterial: import("three").Material;
            customDistanceMaterial: import("three").Material;
            readonly isObject3D: true;
            onBeforeRender: (renderer: import("three").WebGLRenderer, scene: import("three").Scene, camera: import("three").Camera, geometry: import("three").BufferGeometry, material: import("three").Material, group: import("three").Group) => void;
            onAfterRender: (renderer: import("three").WebGLRenderer, scene: import("three").Scene, camera: import("three").Camera, geometry: import("three").BufferGeometry, material: import("three").Material, group: import("three").Group) => void;
            applyMatrix4(matrix: import("three").Matrix4): void;
            applyQuaternion(quaternion: import("three").Quaternion): any;
            setRotationFromAxisAngle(axis: import("three").Vector3, angle: number): void;
            setRotationFromEuler(euler: import("three").Euler): void;
            setRotationFromMatrix(m: import("three").Matrix4): void;
            setRotationFromQuaternion(q: import("three").Quaternion): void;
            rotateOnAxis(axis: import("three").Vector3, angle: number): any;
            rotateOnWorldAxis(axis: import("three").Vector3, angle: number): any;
            rotateX(angle: number): any;
            rotateY(angle: number): any;
            rotateZ(angle: number): any;
            translateOnAxis(axis: import("three").Vector3, distance: number): any;
            translateX(distance: number): any;
            translateY(distance: number): any;
            translateZ(distance: number): any;
            localToWorld(vector: import("three").Vector3): import("three").Vector3;
            worldToLocal(vector: import("three").Vector3): import("three").Vector3;
            lookAt(vector: number | import("three").Vector3, y?: number, z?: number): void;
            add(...object: Object3D<import("three").Event>[]): any;
            remove(...object: Object3D<import("three").Event>[]): any;
            removeFromParent(): any;
            clear(): any;
            attach(object: Object3D<import("three").Event>): any;
            getObjectById(id: number): Object3D<import("three").Event>;
            getObjectByName(name: string): Object3D<import("three").Event>;
            getObjectByProperty(name: string, value: string): Object3D<import("three").Event>;
            getWorldPosition(target: import("three").Vector3): import("three").Vector3;
            getWorldQuaternion(target: import("three").Quaternion): import("three").Quaternion;
            getWorldScale(target: import("three").Vector3): import("three").Vector3;
            getWorldDirection(target: import("three").Vector3): import("three").Vector3;
            raycast(raycaster: import("three").Raycaster, intersects: import("three").Intersection<Object3D<import("three").Event>>[]): void;
            traverse(callback: (object: Object3D<import("three").Event>) => any): void;
            traverseVisible(callback: (object: Object3D<import("three").Event>) => any): void;
            traverseAncestors(callback: (object: Object3D<import("three").Event>) => any): void;
            updateMatrix(): void;
            updateMatrixWorld(force?: boolean): void;
            updateWorldMatrix(updateParents: boolean, updateChildren: boolean): void;
            toJSON(meta?: {
                geometries: any;
                materials: any;
                textures: any;
                images: any;
            }): any;
            clone(recursive?: boolean): any;
            copy(source: any, recursive?: boolean): any;
            addEventListener<T_6 extends string>(type: T_6, listener: import("three").EventListener<import("three").Event, T_6, any>): void;
            hasEventListener<T_7 extends string>(type: T_7, listener: import("three").EventListener<import("three").Event, T_7, any>): boolean;
            removeEventListener<T_8 extends string>(type: T_8, listener: import("three").EventListener<import("three").Event, T_8, any>): void;
            dispatchEvent(event: import("three").Event): void;
        };
        _dummy: any;
        _orientation: number;
        _index: number;
        _uniforms: any;
        _autoWindowLevel: boolean;
        _outOfBounds: boolean;
        _orientationMaxIndex: number;
        _orientationSpacing: number;
        _canvasWidth: number;
        _canvasHeight: number;
        _borderColor: any;
        stack: ModelsStack;
        readonly bbox: HelpersBoundingBox;
        readonly slice: HelpersSlice;
        readonly border: HelpersSlice;
        index: number;
        orientation: number;
        outOfBounds: boolean;
        orientationMaxIndex: number;
        orientationSpacing: number;
        canvasWidth: number;
        canvasHeight: number;
        borderColor: any;
        _create(): void;
        _computeOrientationSpacing(): void;
        _computeOrientationMaxIndex(): void;
        _isIndexOutOfBounds(): void;
        _prepareStack(): void;
        _prepareBBox(): void;
        _prepareBorder(): void;
        _prepareSlice(): void;
        _prepareSliceIndex(indices: import("three").Vector3): number;
        _prepareSlicePosition(rPosition: import("three").Vector3, index: number): number;
        _prepareDirection(orientation: number): import("three").Vector3;
        dispose(): void;
        id: number;
        uuid: string;
        name: string;
        type: string;
        parent: Object3D<import("three").Event>;
        children: Object3D<import("three").Event>[];
        up: import("three").Vector3;
        readonly position: import("three").Vector3;
        readonly rotation: import("three").Euler;
        readonly quaternion: import("three").Quaternion;
        readonly scale: import("three").Vector3;
        readonly modelViewMatrix: import("three").Matrix4;
        readonly normalMatrix: import("three").Matrix3;
        matrix: import("three").Matrix4;
        matrixWorld: import("three").Matrix4;
        matrixAutoUpdate: boolean;
        matrixWorldNeedsUpdate: boolean;
        layers: import("three").Layers;
        visible: boolean;
        castShadow: boolean;
        receiveShadow: boolean;
        frustumCulled: boolean;
        renderOrder: number;
        animations: import("three").AnimationClip[];
        userData: {
            [key: string]: any;
        };
        customDepthMaterial: import("three").Material;
        customDistanceMaterial: import("three").Material;
        readonly isObject3D: true;
        onBeforeRender: (renderer: import("three").WebGLRenderer, scene: import("three").Scene, camera: import("three").Camera, geometry: import("three").BufferGeometry, material: import("three").Material, group: import("three").Group) => void;
        onAfterRender: (renderer: import("three").WebGLRenderer, scene: import("three").Scene, camera: import("three").Camera, geometry: import("three").BufferGeometry, material: import("three").Material, group: import("three").Group) => void;
        applyMatrix4(matrix: import("three").Matrix4): void;
        applyQuaternion(quaternion: import("three").Quaternion): any;
        setRotationFromAxisAngle(axis: import("three").Vector3, angle: number): void;
        setRotationFromEuler(euler: import("three").Euler): void;
        setRotationFromMatrix(m: import("three").Matrix4): void;
        setRotationFromQuaternion(q: import("three").Quaternion): void;
        rotateOnAxis(axis: import("three").Vector3, angle: number): any;
        rotateOnWorldAxis(axis: import("three").Vector3, angle: number): any;
        rotateX(angle: number): any;
        rotateY(angle: number): any;
        rotateZ(angle: number): any;
        translateOnAxis(axis: import("three").Vector3, distance: number): any;
        translateX(distance: number): any;
        translateY(distance: number): any;
        translateZ(distance: number): any;
        localToWorld(vector: import("three").Vector3): import("three").Vector3;
        worldToLocal(vector: import("three").Vector3): import("three").Vector3;
        lookAt(vector: number | import("three").Vector3, y?: number, z?: number): void;
        add(...object: Object3D<import("three").Event>[]): any;
        remove(...object: Object3D<import("three").Event>[]): any;
        removeFromParent(): any;
        clear(): any;
        attach(object: Object3D<import("three").Event>): any;
        getObjectById(id: number): Object3D<import("three").Event>;
        getObjectByName(name: string): Object3D<import("three").Event>;
        getObjectByProperty(name: string, value: string): Object3D<import("three").Event>;
        getWorldPosition(target: import("three").Vector3): import("three").Vector3;
        getWorldQuaternion(target: import("three").Quaternion): import("three").Quaternion;
        getWorldScale(target: import("three").Vector3): import("three").Vector3;
        getWorldDirection(target: import("three").Vector3): import("three").Vector3;
        raycast(raycaster: import("three").Raycaster, intersects: import("three").Intersection<Object3D<import("three").Event>>[]): void;
        traverse(callback: (object: Object3D<import("three").Event>) => any): void;
        traverseVisible(callback: (object: Object3D<import("three").Event>) => any): void;
        traverseAncestors(callback: (object: Object3D<import("three").Event>) => any): void;
        updateMatrix(): void;
        updateMatrixWorld(force?: boolean): void;
        updateWorldMatrix(updateParents: boolean, updateChildren: boolean): void;
        toJSON(meta?: {
            geometries: any;
            materials: any;
            textures: any;
            images: any;
        }): any;
        clone(recursive?: boolean): any;
        copy(source: any, recursive?: boolean): any;
        addEventListener<T_9 extends string>(type: T_9, listener: import("three").EventListener<import("three").Event, T_9, any>): void;
        hasEventListener<T_10 extends string>(type: T_10, listener: import("three").EventListener<import("three").Event, T_10, any>): boolean;
        removeEventListener<T_11 extends string>(type: T_11, listener: import("three").EventListener<import("three").Event, T_11, any>): void;
        dispatchEvent(event: import("three").Event): void;
    };
    set file(arg: any);
    get file(): any;
    set progressbarContainer(arg: any);
    get centerLPS(): any;
    get stack(): any;
    _createSlice(orientation: any): void;
    load(): Promise<any>;
}
import { Object3D } from "three/src/core/Object3D";
//# sourceMappingURL=helpers.x.volume.d.ts.map